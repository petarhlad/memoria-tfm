\chapter{Preliminaries}

Some cryptographic preliminaries and other definitions.

\section{Homomorphic Public Key Encryption}
Let 多? be a public key cryptosystem with encryption algorithm (function?) $\mathcal{E}$ and decryption algorithm (function?) $\mathcal{D}$ where:
$m' \leftarrow \mathcal{E}_{pk} (m)$ and $m \leftarrow \mathcal{D}_{sk} (m')$

Let $(G,\bullet)$ and $(H,\circ)$ be two groups such that $\mathcal{E}_{pk}: G \rightarrow H$.

Then, 多? is a Homomorphic Public Key Encryption Scheme if
$$ \mathcal{E}_{sk} (m_1 \bullet m_2) \leftarrow \mathcal{E}_{sk} (m_1) \circ \mathcal{E}_{sk} (m_2)$$

Example:
\textbf{ElGamal}


\section{Oblivious Polynomial Evaluation}
Oblivious polynomial evaluation is a protocol involving two parties, a sender whose input is a polynomial $P \in \FF[x]$, and a receiver whose input is a value $\alpha \in \FF$. At the end of the protocol, the receiver learns $P(\alpha)$ and the sender learns nothing.

\subsection{Noisy Polynomial problem}

\citeauthor{OPE} proposed in \cite{OPE} a protocol for Oblivious Polynomial Evaluation that relies on the hardness of the Noisy Polynomial Reconstruction problem.

Generic Protocol:

\begin{itemize}
    \item Input:
    
    \begin{itemize}
        \item Sender: a polynomial $P(y) = \sum_{i=0}^{d_P} b_i y^i$ of degree $d_P$ in the field $\FF$.
        \item Receiver: a value $\alpha \in \FF$
    \end{itemize}
    
    \item Output:
    
    \begin{itemize}
        \item Sender: nothing.
        \item Receiver: $P(\alpha)$
    \end{itemize}
    
    \item Protocol security parameters: $m$, $k$.
    
\end{itemize}

Generic protocol for oblivious polynomial evaluation:

\begin{itemize}[align = left, leftmargin=*]

\item[\textbf{1. The sender hides $P$ in a bivariate polynomial:}]

The sender generates a random masking polynomial $P_x (x)$ of degree $d$, s.t. $P_x (0) = 0$, where $d = k \cdot d_P$.
$$P_x (x) = \sum_{i=1}^{d} a_i x^i$$

The sender defines a bivariate polynomial
$$ Q(x,y) = P_x(x) + P(y) = \sum_{i=1}^{d} a_i x^i + \sum_{i=0}^{d_P} b_i y^i $$

\item[\textbf{2. The receiver hides $\alpha$ in a univariate polynomial:}]

The receiver chooses a random polynomial $S$ of degree $k$, such that $S(0) = \alpha$.

Define $R(x) = Q( x, S(x))$. The goal of the receiver is to use $R(x)$ to learn $P(\alpha)$. Note that $R(0) = Q(0,S(0)) = P(S(0)) = P(\alpha)$.

\item[\textbf{3. The receiver learns points of R:}] The receiver learns $d_R + 1$ values of the form $\left\langle x_i , R(x_i) \right\rangle$.

\item[\textbf{4. The receiver computes $P(\alpha)$:}] The receiver uses the values of $R$ that it learned to interpolate $R(0)=P(\alpha)$.

\end{itemize}

The key is in the third step on how the receiver learns $d_R + 1$ evaluations of $R(x)$ in a secure way.

\begin{itemize}[align = left, leftmargin=*]
\item The receiver sets $n = d_R + 1$ and chooses $N = nm$ distinct random values $x_1, \cdots, x_N \in \FF$, all different from $0$.

\item The receiver chooses a random set $T$ of $n$ indices $1 \leq i_1 < i_2 < \cdots < i_n \leq N$. Then defines $N$ values $y_i$:
    $$y_i = 
        \begin{cases}
            S(x_i)        & \mbox{if } i \in T \\
            y_i \in_R \FF & \mbox{if } i \notin T
        \end{cases} $$
        
\item The receiver sends the $N$ points $\{(x_i, y_i)\}^N_{i=1}$ to the sender.

\item The receiver and sender execute an $n$-out-of-$N$ oblivious transfer protocol, for the $N$ values $Q(x_i,y_i)$. The receiver chooses to learn $\{Q(x_i,y_i)\}_{i\in T}$
\end{itemize}


\subsection{Homomorphic PKE}
Let $多?$ be a Homomorphic Public Key Encryption Scheme with (多possibly probabilistic?) encoding and decoding functions $\E: G \rightarrow H$ and $\D: H \rightarrow G$. Where $(G,\bullet)$ and $(H,\circ)$ are groups.

We will write $G$ additively, and $H$ multiplicatively.

The sender knows a polynomial $P(x) = \sum_{i=0}^d a_i x^i$ with $a_i \in \ZZ$ of degree $d$ which can be evaluated on the group $G$. 

The receiver encrypts the powers of $\alpha$: $\beta_i \leftarrow \E(\alpha^i)$ for $i \in \{0, ..., d\}$ and sends them to the sender.

The sender uses the homomorphic property of the encryption scheme to compute $\beta = \E(P(\alpha)) \leftarrow \beta_0^{a_0} \cdot \beta_1^{a_1} \cdot ... \cdot \beta_n^{a_n}$ and sends it to the receiver.

The receiver decrypts the received value to get $P(\alpha)$:
$\D(\beta) = \D(\E(P(\alpha))) = P(\alpha) $




\section{Secret Sharing}
\subsection{Definitions}
Definition of access structures and secret sharing

\cite{Phillips1992}
\cite{BlSt97}

An access structure $\Gamma$ is the set of all subsets of $\PP$ that can recover the secret.

\defn Let $\PP := \{ P_1, \dots, P_n \}$ be a set of participants. A \textit{monotone access structure} $\Gamma$ on $\PP$ is a subset $\Gamma \subseteq 2^{\PP}$, which is monotone increasing $$ A \in \Gamma, \quad A \subseteq A' \subseteq \PP \Rightarrow A' \in \Gamma $$

\defn Let $\PP := \{ P_1, \dots, P_n \}$ be a set of participants and let $A \subseteq 2^{\PP}$. The \textit{closure} of $A$, denoted $\cl (A)$, is the set $$ \cl (A) = \{ C: \exists B \in A \text{ s.t. } B \subseteq C \subseteq \PP \}$$

For a monotone access structure $\Gamma$ we have $\Gamma = \cl (\Gamma)$.

\defn Let $\Gamma$ be an access structure on a set of participants $\PP$. $B \in \Gamma$ is a \textit{minimal} qualified set if $A \notin \Gamma$ whenever $A \subsetneq B$.

\defn Let $\Gamma$ be an access structure on a set of participants $\PP$. The family of minimal qualified sets $\Gamma_{0}$ of $\Gamma$ is called the \textit{basis} of $\Gamma$.

For a basis $\Gamma_0$ of an access structure $\Gamma$ we have $\Gamma = \cl (\Gamma_{0})$

\defn An access structure $\Gamma$ is \textit{trivial} if either $\Gamma = 2^{\PP}$ or $\Gamma = \{ \PP \}$.

Let $\mathcal{K}$ be a set of $q$ elements called \textit{secret keys}, and let $\mathcal{S}$ be a finite set whose elements are called \textit{shares}. Let $D$ be a \textit{dealer} who wants to share a secret key $\mathbf{k} \in \mathcal{K}$ among the participants in $\PP$. 

\defn A \textit{distribution rule} is a function $f : \PP \cup \{ D \} \rightarrow \KK \cup \SS$ which satisfies the conditions $f(D) \in \KK$ and $f(P_i) \in \SS$ for $i = 1,2, \dots, n$.

Secret sharing schemes will be represented by a collection of distribution rules, which represent a possible distribution of shares to the participants where $f(D)$ is the secret key being shared and $f(P_i)$ is the share given to $P_i$.

\defn Let $\mathscr{F}$ be a family of distribution rules, and let $\mathbf{k} \in \KK$. Then $\mathscr{F}_{\mathbf{k}} := \{ f \in \mathscr{F} : f(F) = \mathbf{k}\}$ is the family of all distribution rules having $\mathbf{k}$ as secret.

If $\kk \in \KK$ is the secret that $D$ wants to share, then $D$ will chose a distribution rule $f \in \F_{\KK}$ uniformly at random.


Let $\{p_{\KK} (\kk) \}_{\kk \in \KK}$ be a probability distribution on $\KK$, and let a collection of distribution rules for secrets in $\KK$ be fixed.

\defn A \textit{perfect secret sharing scheme}, with respect to a monotone access structure $\Gamma \subseteq 2^{\PP}$, is a collection of distribution rules that satisfy the following two properties:
\begin{enumerate}
    \item If a subset $A \in \Gamma$ of participants pool their shares, then they can determine the value of the secret $\kk$.
    \item If a subset $A \notin \Gamma$ of participants pool their shares, then they can determine nothing about the value of the secret $\kk$. Formally, if $A \notin \acc$ then for all $a = \{ (P_i, s_i): P_i \in A \text{ and } s_i \in \SS \}$ with $p(a)>0$, and for all $\kk \in \KK$, it holds $p(\kk \vert a) = p_{\KK}(\kk)$. In other words, the \textit{a priori} probability of the value of $\kk$ does not change after knowing the shares held by $A$.
\end{enumerate}

\defn An \textit{ideal secret sharing scheme} is a secret sharing scheme for which $\vert \KK \vert = \vert \SS \vert$. An access structure admitting an ideal secret sharing scheme will be referred as \textit{ideal access structure}.

%\thm \sout{Let $\acc$ be an access structure on a set of participants $\PP$. An ideal anonymous secret sharing scheme for $\acc$ exists if and only if either $\acc$ is a $(1,\vert \PP \vert)$ threshold structure, a $(\vert \PP \vert, \vert \PP \vert)$ threshold structure, or the closure of a complete bipartite graph.}

\subsection{Shamir Secret Sharing}
Shamir secret sharing described in \cite{Sham79}.

The scheme is based on polynomial interpolation.

Let $p$ be a large prime number. All operations are done in $\ZZ_p$

We want to share a secret $s$ into $n$ shares so that the secret can be recovered with any $k$ distinct shares.

Let $q(x) = a_0 + a_1 x + \cdots + a_{k-1} x^{k-1}$ be a random polynomial of degree $k-1$ in which $a_0 = s$.

Each participant $i$ in $\PP = \{ 1, ... , n \}$ is given a different random number $x_i \in \ZZ_p$ which identifies the participant.
Then, each participant $i$ is given the share $y_i = q(x_i)$.

To recover the secret, we only need $k$ different shares. Let $P \subset \PP$ be any subset of $k$ participants. Then

Let $\lambda_i^{P} = \prod_{P_j \in (P \setminus P_i)} \frac{-x_j}{x_i - x_j}$

$$
    q(x) = \sum_{i \in P} y_i \prod_{\substack{j \in P \\ i \neq j}} \frac{x-x_j}{x_i-x_j}
$$

Then, $s = q(0)$.

\subsection{Anonymous secret sharing}


\section{Digital Signatures}
To ensure integrity of data in communications and authentication, the concept of digital signatures was developed. 

A digital signature scheme consists of 3 algorithms:
\begin{itemize}
    \item \textbf{Key generation}: on input of a security parameter $k$ (usually the desired length for the keys), outputs a pair $(sk, pk)$ of secret and public keys.
    \item \textbf{Signature}: given an input message $m$ and the secret key $sk$, outputs a signature $\sigma$.
    \item \textbf{Verification}: given an input message $m$, a signature $\sigma$ on the message and a public key $pk$, outputs whether the signature is valid or not.
\end{itemize}

A signature scheme must satisfy the following properties:
\begin{itemize}
    \item \textbf{Correctness}: A signature generated with the signing algorithm must always be accepted by the verifier.
    \item \textbf{Unforgeability}: Only a user can sign messages on behalf of himself.
    \item \textbf{Non-repudiation}: 
\end{itemize}

\subsection{Examples}
\subsubsection*{ElGamal}
\cite{elGamal85}
Let $H$ be a collision-resistant hash function. Let $p$ be a large prime such that the \textit{discrete logarithm problem} is difficult over $\ZZ_p$. Let $g$ be a randomly chosen generator of $\ZZ_p^\ast$

\begin{itemize}[align = left, leftmargin=*]
	\item[\textbf{Key generation.}]	Randomly choose a secret key $x \in \ZZ_p^\ast$, and compute the public key $y = g^x$.
	
	\item[\textbf{Signature.}]To sign a message $m$, the signer chooses a random $k \in \ZZ_p^\ast$.
Compute $ r = g^k$. To compute $s$, the following equation must be satisfied: $g^{H(m)} = g^{xr} g^{ks}$.
So $s = \left( H(m) - xr \right) k^{-1} \quad (\text{mod } p-1)$

If $s=0$, it starts over again with a different $k$.

The pair $(r,s)$ is the digital signature for $m$.

	\item[\textbf{Verification.}]Check $g^{H(m)} = y^r r^s$

The use of $H( \cdot )$ prevents an existential forgery attack.

\end{itemize}

\subsubsection*{Boneh-Lynn-Shacham (BLS)}
\label{sec:bls}
\cite{BonehLS01}
Let $G_1,G_2$ be a bilinear group pair of prime order $p$. Let $g$ be a generator of $G_1$. Let $e:G_1 \times G_2 \rightarrow G_T$ be a non-degenerate bilinear pairing. Let $H: \{0,1\}^* \rightarrow G_1$ be a full-domain hash function.

\begin{itemize}[align = left, leftmargin=*]
	\item[\textbf{Key generation.}] Randomly choose a secret key $x \in \ZZ_p$. The public key is $y = g_2^x$.
	
	\item[\textbf{Signature.}] Given a private key $x \in \ZZ_p$, and a message $m \in \{0,1\}^*$, compute $h = H(m) \in G_1$ and $\sigma = h^x$. The signature is $\sigma \in G_1$.
	
	\item[\textbf{Verification.}] Given a public key $y$, a message $m \in \{0,1\}^*$ and a signature $\sigma \in G_1$, compute $h = H(m) \in G_1$ and verify that $e(\sigma,g_2) = e \left( h, y \right)$.
	
\end{itemize}

\subsubsection*{Schnorr}
\cite{Schnorr90}
Let $G$ be a cyclic group of prime order $p$. Let $g$ be a generator of $G$. Let $H : \{0,1\}^\ast \rightarrow \ZZ_p$ be a hash function.

\begin{itemize}[align = left, leftmargin=*]
	\item[\textbf{Key generation.}]	Randomly choose a secret key $x \in \ZZ_p$. The public key will be $y = g^x$.
	\item[\textbf{Signature.}] Randomly choose $z \in  \ZZ_p$, and compute $L := g^z$. \\
Compute $c := H(L \parallel m)$. \\
Compute $s := z + c \cdot x$ \\
The signature on $m$ is $\sigma = (c,s)$.
	\item[\textbf{Verification.}] Given a signature $\sigma$ and a public key $y$, computes $L^{\dagger} := g^{s} y^{-c}$ and then check that $c = H(L^{\dagger} \parallel m) $
\end{itemize}

\section{Group Signatures}
(With linkability)
Use of aggregation: group signatures. They are used to sign on behalf of the group, prove group membership.

The easiest way is to give everyone the secret key, so they can sign. But this would let any colluded user to share the secret key to other parties, which is not admissible.

Some group signatures need what is called a Dealer, which will deal with the keys.

Examples of Group signatures:

\section{Threshold Digital Signatres}
Definition and example (shamir)

\subsection{Shamir}
\label{sec:shamir_sig}

This signature scheme is based on the BLS scheme (see section \ref{sec:bls}).

\subsubsection*{Setup Algorithm}

\begin{itemize}[align = left, leftmargin=*, label={--}]
\item Let $\mathcal{P}= \{ P_1, \dots , P_n \}$ be the set of participants. Let $G$ be a gap group of large prime order $p > n$. Let $g \in G$ be a generator of the group.

\item Let $sk \in_R \ZZ_p$ be the secret key of the threshold signature scheme. Set $pk = g^{sk}$ the public key. Let $P(x)$ be a random polynomial over $\ZZ_p$ of degree $t-1$ with $P(0) = sk$.

\item Let $\alpha_1, ..., \alpha_n \in_R \ZZ_p$ all distinct. Each participant $P_i \in \PP$ is assigned a public key $pk_i = \alpha_i$ and a secret key $sk_i = s_i := P(\alpha_i)$.

\end{itemize}

Note that, for any set $\{P_{i_1}, ... , P_{i_t} \} = P \subseteq \PP$ of $t$ participants: $$sk = P(0) = \sum_{j = 1}^t s_{i_j} \lambda_{i_j}^P$$ where $\lambda_{i_j}^P := \prod_{k \in [t] \setminus \{j\}} \frac{-\alpha_k}{\alpha_j - \alpha_k}$

\subsubsection*{Signing Algorithm}
\begin{itemize}[align = left, leftmargin=*, label={--}]

\item Let $P = \{P_{i_1}, ..., P_{i_t} \}$ be a set of $t$ participants. Each participant $P_{i_j}$ computes his partial signature $\sigma_{i_j} (m) = H(m)^{s_{i_j}}$ and broadcasts the pair $(\alpha_{i_j}, \ \sigma_{i_j} (m))$.

\item The signature $\sigma$ on $m$ is computed: $$ \sigma (m) = \prod_{P_i \in P} \sigma_i (m)^{\lambda_i^{P}}= H(m)^{\sum_{P_i \in P} \lambda_i^P s_i} = H(m)^{sk}$$
\end{itemize}

\subsubsection*{Verifying Algorithm}
\begin{itemize}[align = left, leftmargin=*, label={--}]
\item Let $e: G \times G \rightarrow G_t$ be a bilinear pairing. Let $\sigma$ be a signature on a message $m$.
\item The signature $\sigma$ on $m$ is valid if and only if $e(\sigma, g) = e(H(m), pk)$
\end{itemize}

\section{Bilinear pairings}
\cite{DiHe76}

Let $G_1$ and $G_2$ be two (multiplicative) cyclic groups of prime order $q$. Let $g_1$ be a fixed generator of $G_1$ and $g_2$ be a fixed generator of $G_2$.

\defn Computation Diffie-Hellman (CDH) Problem: Given a randomly chosen $g \in G_1$, $g^a$, and $g^b$ (for unknown randomly chosen $a,b \in \ZZ_q$), compute $g^{ab}$.

\defn Decision Diffie-Hellman (DDH) Problem: Given randomly chosen $g \in G_1$, $g^a$, $g^b$, and $g^c$ (for unknown randomly chosen $a,b,c \in \ZZ_q$), decide whether $c = ab$. (If so, $(g, g^a, g^b, g^c)$ is called a valid Diffie-Hellman tuple.)

\defn Computational co-Diffie-Hellman (co-CDH) Problem on $(G_1, G_2)$: Given $g_2, g^a_2 \in G_2$ and $h \in G_1$ as input, compute $h^a \in G_1$.

\defn Decision co-Diffie-Hellman (co-DDH) on $(G_1, G_2)$: Given $g_2, g^a_2 \in G_2$ and $h, h^b \in G_1$ as input, decide whether $a=b$. If so, we say that $(g_2, g^a_2, h, h^a)$ is a co-Diffie-Hellman tuple.

\defn Bilinear map: Let $G_T$ be an additional group such that $ |G_1| = |G_2| = |G_T| $. A bilinear map is a map $e: G_1 \times G_2 \rightarrow G_T$ with the following properties:
\begin{enumerate}

\item Bilinear: for all $u \in G_1, v \in G_2$ and $a,b \in \ZZ$, $e(u^a, v^b) = e(u,v)^{ab}$.
\item Non-degenerate: $e(g_1, g_2) \neq 1$.

\end{enumerate}

\defn A Gap co-Diffie-Hellman (co-GDH) group pair is a pair of groups $(G_1, G_2)$ on which co-DDH is easy but co-CDH is hard. When $(G_1, G_1)$ is a co-GDH group pair, we say $G_1$ is a Gap group (GDH).

\remk If there s a bilinear map on $G_1, G_2$, then they are a co-GDH group pair. If there is a bilinear map over $G_1 \times G_1$, then $G_1$ is a gap group, since one can use the bilinear map to solve the DDH problem.