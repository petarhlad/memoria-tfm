\chapter{Preliminaries}

Some cryptographic preliminaries and other definitions.

\newpage

\section{Bilinear pairings}
\cite{DiHe76}

Let $G_1$ and $G_2$ be two (multiplicative) cyclic groups of prime order $q$. Let $g_1$ be a fixed generator of $G_1$ and $g_2$ be a fixed generator of $G_2$.

\defn Computation Diffie-Hellman (CDH) Problem: Given a randomly chosen $g \in G_1$, $g^a$, and $g^b$ (for unknown randomly chosen $a,b \in \ZZ_q$), compute $g^{ab}$.

\defn Decision Diffie-Hellman (CDH) Problem: Given randomly chosen $g \in G_1$, $g^a$, $g^b$, and $g^c$ (for unknown randomly chosen $a,b,c \in \ZZ_q$), decide whether $c = ab$. (If so, $(g, g^a, g^b, g^c)$ is called a valid Diffie-Hellman tuple.)

\defn Computational co-Diffie-Hellman (co-CDH) Problem on $(G_1, G_2)$: Given $g_2, g^a_2 \in G_2$ and $h \in G_1$ as input, compute $h^a \in G_1$.

\defn Decision co-Diffie-Hellman (co-DDH) on $(G_1, G_2)$: Given $g_2, g^a_2 \in G_2$ and $h, h^b \in G_1$ as input, decide whether $a=b$. If so, we say that $(g_2, g^a_2, h, h^a)$ is a co-Diffie-Hellman tuple.

\defn Bilinear map: Let $G_T$ be an additional group such that $ |G_1| = |G_2| = |G_T| $. A bilinear map is a map $e: G_1 \times G_2 \rightarrow G_T$ with the following properties:
\begin{enumerate}

\item Bilinear: for all $u \in G_1, v \in G_2$ and $a,b \in \ZZ$, $e(u^a, v^b) = e(u,v)^{ab}$.
\item Non-degenerate: $e(g_1, g_2) \neq 1$.

\end{enumerate}

\defn A gap group is a group on which the DDH problem is easy but the CDH is hard.

\newpage

\section{Homomorphic PKE}

\section{Digital Signatures}
To ensure integrity of data in communications and authentication, the concept of digital signatures was developed. 

A digital signature scheme consists of 3 algorithms:
\begin{itemize}
    \item \textbf{Key generation}: on input of a security parameter $k$ (usually the length), outputs a pair $(sk, pk)$ of secret and public keys.
    \item \textbf{Signature}: given an input message $m$ and the secret key $sk$, outputs a signature $\sigma$.
    \item \textbf{Verification}: given an input message $m$, a signature $\sigma$ on the message and a public key $pk$, outputs whether the signature is valid or not.
\end{itemize}

A signature scheme must satisfy the following properties:
\begin{itemize}
    \item \textbf{Correctness}: A signature generated with the signing algorithm must always be accepted by the verifier.
    \item \textbf{Unforgeability}: Only a user can sign messages on behalf of himself.
    \item \textbf{Non-repudiation}: 
\end{itemize}

\subsection{Examples}
\subsubsection{ElGamal}
Let $H$ be a collision-resistant hash function. Let $p$ be a large prime such that the \textit{discrete logarithm problem} is difficult over $\ZZ_p$. Let $g$ be a randomly chosen generator of $\ZZ_p^\ast$

\paragraph{Key Generation}

Randomly choose a secret key $x \in \ZZ_p^\ast$, and compute the public key $y = g^x$.

\paragraph{Signature}

To sign a message $m$, the signer chooses a random $k \in \ZZ_p^\ast$.
Compute $ r = g^k$. To compute $s$, the following equation must be satisfied: $g^{H(m)} = g^{xr} g^{ks}$.
So $s = \left( H(m) - xr \right) k^{-1} \quad (\text{mod } p-1)$

If $s=0$, it starts over again with a different $k$.

The pair $(r,s)$ is the digital signature for $m$.

\paragraph{Verification}

Check $g^{H(m)} = y^r r^s$

The use of $H( \cdot )$ prevents an existential forgery attack.

\subsubsection{Boneh-Lynn-Shacham (BLS)}
\cite{BonehLS01}
Let $G,G_T$ be (Â¿gap?) groups of prime order $p$. Let $g$ be a generator of $G$. Let $e:G \times G \rightarrow G_T$ be a non-degenerate bilinear pairing.
\paragraph{Key Generation}

Randomly choose a secret key $x \in \ZZ_p$. The public key will be $y = g^x$.

\paragraph{Signature}

The signature on $m$ is $\sigma = H(m)^x$.

\paragraph{Verification}

Given a signature $\sigma$ and a public key $g^x$, it verifies that $e(\sigma,g) = e \left( H(m), g^x \right)$.

\section{Signature Aggregation}
Explain how different signature schemes allow aggregation of n signatures on n messages from n signers.

\newpage
\section{Group Signatures}
Use of aggregation: group signatures. They are used to sign on behalf of the group, prove group membership.

The easiest way is to give everyone the secret key, so they can sign. But this would let any colluded user to share the secret key to other parties, which is not admissible.

Some group signatures need what is called a Dealer, which will deal with the keys.

Examples of Group signatures:

\section{Shamir Secret Sharing}
Shamir secret sharing described in \cite{Sham79}.

The scheme is based on polynomial interpolation.

Let $p$ be a large prime number. All operations are done in $\ZZ_p$

We want to share a secret $s$ into $n$ shares so that the secret can be recovered with any $k$ distinct shares.

Let $q(x) = a_0 + a_1 x + \cdots + a_{k-1} x^{k-1}$ be a random polynomial of degree $k-1$ in which $a_0 = s$.

Each participant $i$ in $\PP = \{ 1, ... , n \}$ is given a different random number $x_i \in \ZZ_p$ which identifies the participant.
Then, each participant $i$ is given the share $y_i = q(x_i)$.

To recover the secret, we only need $k$ different shares. Let $P \subset \PP$ be any subset of $k$ participants. Then

Let $\lambda_i^{P} = \prod_{P_j \in (P \setminus P_i)} \frac{-x_j}{x_i - x_j}$

$$
    q(x) = \sum_{i \in P} y_i \prod_{\substack{j \in P \\ i \neq j}} \frac{x-x_j}{x_i-x_j}
$$

Then, $s = q(0)$.

\section{Threshold signature scheme using Shamir}
\label{sec:shamir_sig}

This signature scheme will be based on the BLS scheme.

Let $G$ be a gap group of some prime order $p$. Let $g \in G$ be a generator of the group.

Let $\mathcal{P}= \{ 1, \dots , n \}$ be the set of participants in this scheme. Suppose every participant $P_i \in \mathcal{P}$ is given a distinct random number $x_i \in \ZZ_p$ as in the Shamir Secret Sharing Scheme.

Let $SK \in \ZZ_p$ be the secret key of the scheme. Let $q(x) = \sum_{i=0}^{k-1} a_i x^i$ be a random polynomial of degree $k-1$ but fixing $a_0 = SK$.

Each participant $P_i$ is given the share $s_i = q(x_i)$.

So $$SK = \sum_{i \in P} s_i \lambda_i^P$$

To sign a message $m$, each participant $P_i$ computes his partial signature $\sigma_i (m) = H(m)^{s_i}$ and broadcasts the pair $(x_i, \ \sigma_i (m))$.

Then, after a set $P$ of at least $t$ participants has broadcast their partial signatures for the message, a standard signature $\sigma$ can be computed:

$$ \sigma (m) = \prod_{P_i \in P} \sigma_i (m)^{\lambda_i^{P}}= H(m)^{\sum_{P_i \in P} \lambda_i^P s_i} = H(m)^{SK}$$

The signature is valid if $e(\sigma, g) = e(H(m), PK)$

\section{Anonymity}

In order to compare different schemes we need to clear up the definition of anonymity.

The word anonymity is derived from the Greek word \textit{anonymia}, meaning "without a name". In technical terms, the "name" of a participant would be something that uniquely identifies him, e.g. his public key. So, a scheme would be anonymous if the public key of the participant is not disclosed or cannot be obtained in any way at any moment.

It is not very intuitive how we can punt the concept of anonymity in a signature scheme. An anonymous signature does not make much sense. There is no use of an information signed by an anonymous person. What is useful is a signature from a known group of people, but cannot determine from which one nor distinguish two signatures of different participants of the same group on the same message.

- Absolute anonymity. No use. Same as no signature
- Anonymity inside a group. 



You could use ring signatures which proofs the knowledge of a 1-out-of-N secret key. This could be useful for a small amount of signatures. But it is not useful to provide general anonymity.

A signature scheme provides anonymity if:
\begin{itemize}
    \item Unlinkability: cannot decide whether two different signatures were signed by the same user.
    \item Untraceability: cannot get the public key of the signer from a valid signature.
\end{itemize}